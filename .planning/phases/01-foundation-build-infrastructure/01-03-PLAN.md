---
phase: 01-foundation-build-infrastructure
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/lib/calculations.ts
  - src/lib/charts.ts
  - src/lib/export-ppt.ts
autonomous: true

must_haves:
  truths:
    - "Calculation engine produces correct KPI values from canonical data and adjustments as a pure function with no DOM access"
    - "Chart rendering function creates all 11 Chart.js chart types from computed data and canvas refs"
    - "PPT export generates a downloadable .pptx file from calculation results and chart images"
  artifacts:
    - path: "src/lib/calculations.ts"
      provides: "Pure calculation engine — accepts data and params, returns results"
      exports: ["calculateResults", "getFilteredData", "annualizeInjuries"]
      min_lines: 150
    - path: "src/lib/charts.ts"
      provides: "Chart.js rendering for all 11 chart types"
      exports: ["drawCharts", "destroyCharts"]
      min_lines: 400
    - path: "src/lib/export-ppt.ts"
      provides: "PowerPoint file generation from results data"
      exports: ["exportToPPT"]
      min_lines: 100
  key_links:
    - from: "src/lib/calculations.ts"
      to: "src/state/store.ts"
      via: "reads canonical data, adjustments, and selected site from store signals"
      pattern: "canonicalData\\.value|adjustments\\.value|selectedSite\\.value"
    - from: "src/lib/charts.ts"
      to: "Chart"
      via: "CDN global — creates Chart.js instances"
      pattern: "new Chart"
    - from: "src/lib/export-ppt.ts"
      to: "pptxgen"
      via: "CDN global — creates PptxGenJS instance"
      pattern: "new pptxgen"
---

<objective>
Extract the complete "data out" pipeline from the monolith — the calculation engine, Chart.js chart rendering, and PowerPoint export — into typed TypeScript modules. These modules become pure functions that accept data and produce output, with zero DOM access.

Purpose: This creates the output processing backbone. After this plan, the calculation engine can transform canonical data + adjustments into a complete results object, charts can render from that results object, and PPT export can generate a deck — all without touching the DOM.
Output: 3 lib modules (calculations, charts, export-ppt) — the heaviest code extraction in Phase 1.
</objective>

<execution_context>
@~/.cursor/get-shit-done/workflows/execute-plan.md
@~/.cursor/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-build-infrastructure/01-RESEARCH.md

@src/worker.js — The monolith. Key sections to extract:
  - Lines 1682-1710: populateSiteFilter (may overlap with Plan 02 — see note below)
  - Lines 1711-1751: getFilteredData
  - Lines 1752-1803: populateAdjustmentsFromData
  - Lines 1804-1830: annualizeInjuries
  - Lines 1831-2044: calculateAndShowResults (~200 lines — the core calculation engine)
  - Lines 2045-3061: drawCharts (~1000 lines — 11 chart types)
  - Lines 3062-3276: exportToPPT (~200 lines — PowerPoint generation)
  - Lines 3277-3330: toggleAdvanced, calculateObs, applyPreset (utility functions)

@src/state/store.ts — Signal store (from Plan 01). Read data from here.
@src/types/index.ts — Domain interfaces (from Plan 01). Use CalculationResults, CanonicalRecord, AdjustmentParams.

NOTE: `getFilteredData` and `populateSiteFilter` may also be needed by Plan 02's parsing.ts. If Plan 02 has already extracted these, import from parsing.ts. If not (parallel execution), extract here and Plan 04 will reconcile. Use the STORE for communication — both plans write/read signals.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract the calculation engine into a pure TypeScript module</name>
  <files>src/lib/calculations.ts</files>
  <action>
    Extract from monolith lines 1804-2044 (annualizeInjuries + calculateAndShowResults) plus supporting functions (lines 1711-1803, 3277-3330).

    **The critical refactoring:** The monolith's `calculateAndShowResults()` is ~200 lines that reads globals, reads DOM inputs via `el('someId').value`, computes results, writes results to DOM via `el('someId').textContent = ...`, and calls `drawCharts()`. In the refactored version:

    1. **Input:** Read from store signals (canonicalData, adjustments, selectedSite)
    2. **Compute:** Pure calculation logic — no DOM access
    3. **Output:** Return a `CalculationResults` object — no DOM writes
    4. **Side effect:** Write the results to `results.value` signal

    Create these functions:

    ```typescript
    import { canonicalData, adjustments, selectedSite, results, isCalculating } from "../state/store";
    import type { CanonicalRecord, AdjustmentParams, CalculationResults } from "../types";

    /**
     * Filter data by selected site.
     * Pure function — no side effects.
     */
    export function getFilteredData(data: CanonicalRecord[], site: string): CanonicalRecord[] { ... }

    /**
     * Annualize partial-year injury counts.
     * Pure function — takes count and months of data, returns annualized count.
     */
    export function annualizeInjuries(count: number, months: number, shouldAnnualize: boolean): number { ... }

    /**
     * Calculate observation program cost.
     * Pure function.
     */
    export function calculateObservationCost(
      totalEmployees: number,
      obsPerEmployee: number,
      minutesPerObs: number,
      avgHourlyRate: number,
      speedImprovement: number
    ): { currentCost: number; improvedCost: number } { ... }

    /**
     * Apply a preset to adjustment parameters.
     * Returns a new AdjustmentParams object (does not mutate).
     */
    export function getPresetValues(preset: 'conservative' | 'balanced' | 'aggressive'): Partial<AdjustmentParams> { ... }

    /**
     * Main calculation engine. Pure function that takes data + params and returns complete results.
     * This is the refactored version of monolith's calculateAndShowResults().
     *
     * CRITICAL: This function must NOT access the DOM. All inputs come as parameters.
     * All outputs are returned in the CalculationResults object.
     */
    export function computeResults(
      data: CanonicalRecord[],
      params: AdjustmentParams
    ): CalculationResults { ... }

    /**
     * Orchestrator: reads from store, computes, writes results to store.
     * This is the only function with side effects (signal writes).
     */
    export function calculateResults(): void {
      isCalculating.value = true;
      try {
        const data = getFilteredData(canonicalData.value, selectedSite.value);
        const params = adjustments.value;
        const result = computeResults(data, params);
        results.value = result;
      } finally {
        isCalculating.value = false;
      }
    }
    ```

    **Extraction guide for computeResults():**

    Read monolith's `calculateAndShowResults()` (lines 1831-2044) carefully. It:

    1. Gets filtered data (already handled by getFilteredData)
    2. Reads adjustment values from DOM inputs — replace with `params` argument
    3. Counts claims by type (MO vs Indemnity)
    4. Groups by year for trend analysis
    5. Computes category breakdowns (cause, body part)
    6. Computes site comparisons
    7. Calculates TRIR, payback period, ROI
    8. Builds chart data arrays
    9. Sets DOM element values for KPI tiles — replace with RETURN VALUES

    Every `el('someId').value` read → becomes a read from `params`
    Every `el('someId').textContent = ...` write → becomes a field in the return object
    Every reference to `canonicalData` global → uses the `data` parameter

    The returned `CalculationResults` must contain ALL the data needed by:
    - KPI summary tiles (totalClaims, totalIncurred, avgCost, trir, savings, roi, paybackMonths)
    - All 11 chart types (yearly trends, category breakdowns, cost comparisons, projections)
    - PPT export (same data as charts + summary values)

    **Preset values** (from monolith lines 3302-3330):
    - Conservative: wcReduction=20, lostTimeReduction=30, retentionImprovement=5, miscCostReduction=10, obsSpeedImprovement=1.0
    - Balanced: wcReduction=40, lostTimeReduction=60, retentionImprovement=10, miscCostReduction=25, obsSpeedImprovement=1.5
    - Aggressive: wcReduction=80, lostTimeReduction=90, retentionImprovement=25, miscCostReduction=50, obsSpeedImprovement=2.5

    **CalculationResults shape refinement:** The interface in types/index.ts is a starting point. If the monolith's calculateAndShowResults produces data fields not covered by the interface, ADD them. The interface should match what the calculation actually produces. Update `src/types/index.ts` as needed.
  </action>
  <verify>
    1. `npm run typecheck` passes
    2. calculations.ts has NO occurrences of: `document`, `getElementById`, `el(`, `.innerHTML`, `.textContent`, `.value` (DOM access patterns)
    3. `computeResults` is a pure function (takes data + params, returns results)
    4. `calculateResults` reads from store signals and writes `results.value`
    5. All 3 preset configurations are correct (conservative/balanced/aggressive)
  </verify>
  <done>
    calculations.ts exports a pure calculation engine. computeResults takes CanonicalRecord[] + AdjustmentParams and returns CalculationResults with all KPI values, chart data, and breakdown arrays. Zero DOM access.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extract chart rendering and PPT export into typed modules</name>
  <files>
    src/lib/charts.ts
    src/lib/export-ppt.ts
  </files>
  <action>
    **A. Create src/lib/charts.ts**

    Extract from monolith lines 2045-3061 (~1000 lines). The monolith's `drawCharts(data, calculations)` function creates 11 Chart.js chart types.

    **The refactoring:** The monolith's drawCharts:
    - Reads canvas elements via `el('chartId')` → refactored version receives canvas refs as a parameter
    - Reads from local closure variables → refactored version receives CalculationResults
    - Stores instances in global `chartInstances` → refactored version returns instances

    Create:
    ```typescript
    import type { CalculationResults } from "../types";

    /**
     * Destroy all existing chart instances.
     */
    export function destroyCharts(instances: Record<string, any>): void {
      Object.values(instances).forEach(chart => {
        if (chart && typeof chart.destroy === 'function') chart.destroy();
      });
    }

    /**
     * Draw all applicable charts.
     *
     * @param results - Complete calculation results
     * @param canvasRefs - Map of chart ID → HTMLCanvasElement
     * @param existingInstances - Previous chart instances to destroy
     * @param isExistingCustomer - Affects which charts/labels are shown
     * @returns Map of chart ID → new Chart instance
     */
    export function drawCharts(
      results: CalculationResults,
      canvasRefs: Record<string, HTMLCanvasElement | null>,
      existingInstances: Record<string, any>,
      isExistingCustomer: boolean
    ): Record<string, any> { ... }
    ```

    **Extraction approach for the 11 chart types:**

    Read through monolith's drawCharts carefully. Each chart follows a pattern:
    1. Get canvas element → use `canvasRefs[chartId]`
    2. Check if data exists for this chart → skip if not
    3. Create Chart.js config object (type, data, options)
    4. Instantiate: `new Chart(canvas, config)`
    5. Store instance → add to return object

    Chart types in the monolith (identify each by its canvas element ID or chart variable name):
    1. Loss trend line chart (yearly claims/costs over time)
    2. Category breakdown (pie/doughnut — claim types)
    3. Cost comparison (bar — current vs improved)
    4. Body part breakdown (horizontal bar)
    5. Cause of loss breakdown (horizontal bar)
    6. Severity distribution
    7. Monthly trend
    8. TRIR comparison (bar)
    9. Payback timeline
    10. Site comparison (bar)
    11. Observation cost comparison

    For each chart:
    - Copy the Chart.js configuration EXACTLY from the monolith
    - Replace `el('canvasId')` with `canvasRefs['canvasId']`
    - Replace data variable references with `results.chartData[key]` or `results.fieldName`
    - Replace color/style values with the EXACT same values from the monolith
    - Skip chart creation if the canvas ref is null (chart container not rendered)

    **Important:** Keep the existing color scheme and styling. Do not "improve" chart configs — preserve identical visual output.

    **B. Create src/lib/export-ppt.ts**

    Extract from monolith lines 3062-3276 (~200 lines). The monolith's `exportToPPT()` creates a PptxGenJS presentation.

    **The refactoring:** The monolith's exportToPPT:
    - Reads data from DOM elements → refactored version receives CalculationResults
    - Gets chart images from canvas elements → refactored version receives chart image data URLs
    - Reads labels/titles from DOM → refactored version receives them as part of results

    Create:
    ```typescript
    import type { CalculationResults } from "../types";

    /**
     * Generate and download a PowerPoint deck from results.
     *
     * @param results - Complete calculation results
     * @param chartImages - Map of chart ID → base64 data URL from canvas.toDataURL()
     * @param isExistingCustomer - Affects slide content/labels
     */
    export async function exportToPPT(
      results: CalculationResults,
      chartImages: Record<string, string>,
      isExistingCustomer: boolean
    ): Promise<void> { ... }
    ```

    Extraction approach:
    - Copy the PptxGenJS slide creation logic from the monolith
    - Replace `el('someId').textContent` reads with `results.fieldName`
    - Replace `el('chartCanvas').toDataURL()` with `chartImages[chartId]`
    - Replace inline color values with constants (but keep the SAME colors)
    - The function creates a `new pptxgen()` instance, adds slides, then calls `pres.writeFile()`
    - Keep the exact same slide structure, layout, colors, and fonts

    **CRITICAL:** `pptxgen` is a CDN global (declared in globals.d.ts). Reference it directly:
    ```typescript
    // pptxgen is loaded via CDN — declared in src/types/globals.d.ts
    const pres = new pptxgen();
    ```
  </action>
  <verify>
    1. `npm run typecheck` passes — all 3 files compile without errors
    2. charts.ts has NO `document.getElementById`, `el(`, or `.querySelector` — all canvas access via params
    3. export-ppt.ts has NO `document.getElementById`, `el(`, or `.querySelector` — all data via params
    4. charts.ts `drawCharts` returns a Record of chart instances
    5. export-ppt.ts `exportToPPT` calls `pres.writeFile()` to trigger download
    6. All 11 chart types are represented in drawCharts
  </verify>
  <done>
    charts.ts renders all 11 Chart.js chart types from CalculationResults + canvas refs. export-ppt.ts generates a complete PPT deck from CalculationResults + chart images. Both modules have zero DOM queries — they receive all data as function parameters.
  </done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes for all 3 new files
2. Zero DOM access in any file — grep for `document\.|getElementById|\.innerHTML|\.textContent` returns 0 matches in src/lib/calculations.ts, src/lib/charts.ts, src/lib/export-ppt.ts
3. calculations.ts: `computeResults` is pure (takes data + params, returns results)
4. charts.ts: `drawCharts` takes results + canvas refs + existing instances, returns new instances
5. export-ppt.ts: `exportToPPT` takes results + chart images, generates downloadable file
</verification>

<success_criteria>
- Calculation engine produces identical results to the monolith for the same input data and adjustment parameters
- All 11 chart types are extracted with their exact Chart.js configurations preserved
- PPT export creates the same slide structure and content as the monolith
- All three modules are pure TypeScript with explicit types and zero DOM access
- The CalculationResults interface in types/index.ts is updated to match the actual computation output
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-build-infrastructure/01-03-SUMMARY.md`
</output>
