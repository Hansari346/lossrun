---
phase: 01-foundation-build-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/lib/formatting.ts
  - src/lib/field-mapping.ts
  - src/lib/parsing.ts
  - src/components/nav.tsx
  - src/components/upload-page.tsx
autonomous: true

must_haves:
  truths:
    - "Field mapping correctly auto-detects column types from header names using fuzzy scoring"
    - "File upload parses Excel workbooks and populates the signal store with sheet data"
    - "Upload page renders file input, sheet selector, and interactive column mapping table"
  artifacts:
    - path: "src/lib/formatting.ts"
      provides: "Number and currency formatting utilities"
      exports: ["fmtMoney", "fmtInt", "fmtNum"]
    - path: "src/lib/field-mapping.ts"
      provides: "Column auto-mapping with fuzzy matching and field definitions"
      exports: ["normalizeString", "calculateMatchScore", "detectColumnType", "findBestMatch", "requiredFields", "optionalFields"]
    - path: "src/lib/parsing.ts"
      provides: "Excel file parsing, header detection, column mapping, and data loading"
      exports: ["handleFileSelect", "findHeaderRow", "handleSheetSelect", "applyMappingAndLoad", "populateSiteFilter", "getFilteredData"]
    - path: "src/components/upload-page.tsx"
      provides: "Complete upload page with file input, sheet select, mapping table, and data status"
      min_lines: 100
    - path: "src/components/nav.tsx"
      provides: "Wizard navigation bar with 3 step buttons"
      min_lines: 20
  key_links:
    - from: "src/components/upload-page.tsx"
      to: "src/lib/parsing.ts"
      via: "file input onChange triggers handleFileSelect"
      pattern: "handleFileSelect"
    - from: "src/components/upload-page.tsx"
      to: "src/lib/field-mapping.ts"
      via: "mapping table uses field definitions"
      pattern: "requiredFields|optionalFields"
    - from: "src/lib/parsing.ts"
      to: "src/state/store.ts"
      via: "writes parsed data to signals"
      pattern: "workbook\\.value|canonicalData\\.value|headerRow\\.value"
---

<objective>
Extract the data input pipeline from the monolith — formatting utilities, field mapping logic, file parsing, and data loading — into typed TypeScript modules. Build the Preact components for the navigation bar and upload page that wire to these modules via the signal store.

Purpose: This creates the complete "data in" vertical slice. After this plan, a user can upload a file, see sheets detected, view column mappings, and have data loaded into the signal store.
Output: 3 lib modules (formatting, field-mapping, parsing) + 2 Preact components (nav, upload-page).
</objective>

<execution_context>
@~/.cursor/get-shit-done/workflows/execute-plan.md
@~/.cursor/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-build-infrastructure/01-RESEARCH.md

@src/worker.js — The monolith. Key sections to extract:
  - Lines 971-978: fmtMoney, fmtInt, fmtNum formatting functions
  - Lines 1025-1183: normalizeString, calculateMatchScore, detectColumnType, findBestMatch
  - Lines 1186-1247: requiredFields, optionalFields definitions
  - Lines 1321-1370: handleFileSelect
  - Lines 1373-1453: findHeaderRow
  - Lines 1455-1567: handleSheetSelect
  - Lines 1568-1681: applyMappingAndLoad
  - Lines 1682-1803: populateSiteFilter, getFilteredData, populateAdjustmentsFromData
  - Lines 407-519: Upload page HTML structure (page1 div)
  - Lines 407-412: Navigation bar HTML

@src/state/store.ts — Signal store (from Plan 01). Import and use these signals instead of global variables.
@src/types/index.ts — Domain interfaces (from Plan 01). Use these types for function signatures.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract formatting utilities and field mapping logic into typed modules</name>
  <files>
    src/lib/formatting.ts
    src/lib/field-mapping.ts
  </files>
  <action>
    **A. Create src/lib/formatting.ts**

    Extract from monolith lines 971-978. These are pure utility functions with no state dependencies:

    ```typescript
    /** Format a number as currency: $1,234 */
    export function fmtMoney(v: number): string { ... }

    /** Format a number as integer string */
    export function fmtInt(v: number): string { ... }

    /** Format a number with d decimal places */
    export function fmtNum(v: number, d?: number): string { ... }
    ```

    - Keep the exact same formatting logic (NaN/Infinity → em-dash "—")
    - Add TypeScript parameter and return types
    - Do NOT export the `el()` helper — it will not exist in the refactored codebase

    **B. Create src/lib/field-mapping.ts**

    Extract from monolith lines 1025-1247. This is the column auto-mapping engine:

    1. Extract `normalizeString(str)` — lowercases, removes non-alphanumeric, trims
    2. Extract `calculateMatchScore(header, hints)` — fuzzy match scoring algorithm
    3. Extract `detectColumnType(values, expectedType)` — checks if column values match expected type
    4. Extract `findBestMatch(headers, sampleData, fieldDef)` — finds best matching column for a field
    5. Extract `requiredFields` and `optionalFields` objects — the canonical field definitions

    Type all functions using `FieldDefinition` from `src/types/index.ts`:

    ```typescript
    import type { FieldDefinition } from "../types";

    export const requiredFields: Record<string, FieldDefinition> = { ... };
    export const optionalFields: Record<string, FieldDefinition> = { ... };

    export function normalizeString(str: string): string { ... }
    export function calculateMatchScore(header: string, hints: string[]): number { ... }
    export function detectColumnType(values: any[], expectedType: string): boolean { ... }
    export function findBestMatch(headers: string[], sampleData: any[][], fieldDef: FieldDefinition): { index: number; score: number } | null { ... }
    ```

    - These are pure functions with NO state dependencies (no store imports, no DOM access)
    - Copy the matching logic EXACTLY from the monolith — the fuzzy scoring algorithm must be preserved
    - The `requiredFields` have `required: true` set; `optionalFields` do not
    - Add explicit TypeScript types to all parameters and return values
  </action>
  <verify>
    1. `npm run typecheck` passes — no TypeScript errors in the new files
    2. Both files export the expected functions (check with a quick import test or IDE)
    3. `requiredFields` has 3 entries (site_name, date_of_loss, total_incurred)
    4. `optionalFields` has 6 entries (claim_number, claim_category, body_part, lost_days, cause_of_loss, loss_description)
  </verify>
  <done>
    formatting.ts exports fmtMoney/fmtInt/fmtNum with correct TypeScript types. field-mapping.ts exports the complete fuzzy matching engine and field definitions, all typed. No DOM access anywhere.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extract parsing module and create Nav + Upload page components</name>
  <files>
    src/lib/parsing.ts
    src/components/nav.tsx
    src/components/upload-page.tsx
  </files>
  <action>
    **A. Create src/lib/parsing.ts**

    Extract from monolith lines 1321-1803. This is the heaviest extraction — file handling, sheet detection, column mapping, and data loading. All functions MUST use the signal store instead of global variables.

    Functions to extract:

    1. **handleFileSelect(file: File)** — reads an uploaded Excel file via FileReader → XLSX.read(), writes `workbook` signal, auto-selects first sheet, calls findHeaderRow.
       - Monolith reads from `evt.target.files[0]` → refactored version receives `File` directly
       - Writes to: `workbook.value`, `currentSheetName.value`, `statusMessage.value`

    2. **findHeaderRow(sheet, sheetName)** — scans first 20 rows to find the header row based on non-empty cell count. Returns header array.
       - Writes to: `headerRow.value`
       - Returns: `string[]` (the detected headers)

    3. **handleSheetSelect(sheetName: string)** — user selects a different sheet, re-runs header detection.
       - Reads from: `workbook.value`
       - Writes to: `currentSheetName.value`, `headerRow.value`

    4. **applyMappingAndLoad(mappingOverrides: Record<string, number>)** — applies column mappings, reads sheet data, creates canonical records, loads into store.
       - This is the critical data loading function. It reads rows from the sheet, applies the column mapping, creates `CanonicalRecord[]`, and writes to `canonicalData.value`.
       - Also calls populateSiteFilter and populateAdjustmentsFromData.
       - Reads from: `workbook.value`, `currentSheetName.value`, `headerRow.value`
       - Writes to: `mappings.value`, `canonicalData.value`, `availableSites.value`, `adjustments.value`

    5. **populateSiteFilter(data: CanonicalRecord[])** — extracts unique site names from canonical data.
       - Writes to: `availableSites.value`

    6. **getFilteredData()** — returns canonical data filtered by the selected site.
       - Reads from: `canonicalData.value`, `selectedSite.value`
       - Returns: `CanonicalRecord[]`

    7. **populateAdjustmentsFromData(data: CanonicalRecord[])** — auto-populates adjustment values based on ingested data (e.g., injury counts, costs).
       - Writes to: `adjustments.value` (partial update)

    Import pattern:
    ```typescript
    import { workbook, currentSheetName, headerRow, mappings, canonicalData, availableSites, selectedSite, adjustments, statusMessage } from "../state/store";
    import { findBestMatch, requiredFields, optionalFields } from "./field-mapping";
    import type { CanonicalRecord, Mappings } from "../types";
    ```

    **CRITICAL:** Every place the monolith uses `el('someId').value` or `el('someId').textContent = ...` to read/write DOM, replace with signal reads/writes. The parsing module must have ZERO DOM access.

    **B. Create src/components/nav.tsx**

    Render the 3-step wizard navigation bar. Read from `currentPage` signal. Clicking a nav button sets `currentPage.value`.

    Extract from monolith lines ~407-412 (nav HTML). The nav has 3 buttons:
    - "1. Data Ingestion" — always enabled
    - "2. Adjustments" — enabled when `hasData` is true
    - "3. Results" — enabled when `hasData` is true

    ```tsx
    import { currentPage, hasData } from "../state/store";

    export function Nav() {
      return (
        <div class="nav">
          <button class={`nav-btn ${currentPage.value === 1 ? 'active' : ''}`}
                  onClick={() => currentPage.value = 1}>
            1. Data Ingestion
          </button>
          {/* ... buttons 2 and 3 with disabled={!hasData.value} ... */}
        </div>
      );
    }
    ```

    **C. Create src/components/upload-page.tsx**

    Render the complete upload page (page 1). This is the largest component in this plan. Extract from monolith lines ~415-519.

    The page has these sections:
    1. **File upload area** — file input with drag-drop styling
    2. **Sheet selector** — dropdown populated from `sheetNames` signal when workbook has multiple sheets
    3. **Column mapping table** — shows each required/optional field, its detected mapping, confidence indicator, and a dropdown for manual override
    4. **Status/info messages** — shows row counts, data quality feedback
    5. **"Apply Mapping & Continue" button** — calls `applyMappingAndLoad()` then navigates to page 2

    The component should:
    - Use signals for all state (no local DOM queries)
    - Call `handleFileSelect` when a file is selected (pass the File object)
    - Call `handleSheetSelect` when sheet dropdown changes
    - Build the mapping table by iterating over `requiredFields` and `optionalFields`, showing the auto-detected match for each against `headerRow.value`
    - Allow manual override via `<select>` dropdowns showing all available headers
    - Call `applyMappingAndLoad` with the current mappings when the user clicks Apply
    - Navigate to page 2 after successful mapping: `currentPage.value = 2`

    Use `useSignal` or `signal.value` reads in the JSX for reactivity. Use local component signals (via `useSignal`) for UI-only state like mapping overrides.

    **Styling:** Use the existing CSS classes from the extracted styles.css (`.card`, `.mapping-table`, `.pill`, `.badge`, etc.). Do NOT convert to Tailwind utility classes in Phase 1.
  </action>
  <verify>
    1. `npm run typecheck` passes with no errors
    2. `npm run dev` — navigate to localhost, verify the upload page renders (it won't be visible yet in the app since app.tsx is placeholder, but you can temporarily import UploadPage into app.tsx to verify)
    3. Verify parsing.ts has no `document.getElementById`, `el(`, or direct DOM access
    4. Verify parsing.ts imports from store and field-mapping (not from DOM)
  </verify>
  <done>
    parsing.ts handles the full file → canonical data pipeline using signals (zero DOM access). nav.tsx renders the wizard navigation driven by currentPage signal. upload-page.tsx renders the complete upload UI with file input, sheet selection, mapping table, and apply button — all wired to lib functions and the store.
  </done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes — all 5 new files compile without errors
2. formatting.ts: `fmtMoney(1234)` returns `"$1,234"`, `fmtMoney(NaN)` returns `"—"`
3. field-mapping.ts: `findBestMatch(["Total Incurred"], [], requiredFields.total_incurred)` returns a match
4. parsing.ts: No occurrences of `document.getElementById`, `el(`, or `.innerHTML` in the file
5. upload-page.tsx: Renders file input, mapping table structure, and apply button
</verification>

<success_criteria>
- All formatting functions produce identical output to the monolith versions
- Field mapping fuzzy scoring algorithm is exactly preserved
- Parsing module uses ONLY signal store for state (no DOM reads/writes)
- Upload page component renders the full upload UI with interactive mapping table
- Nav component shows 3 steps with correct active/disabled states
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-build-infrastructure/01-02-SUMMARY.md`
</output>
