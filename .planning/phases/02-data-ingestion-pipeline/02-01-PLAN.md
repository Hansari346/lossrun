---
phase: 02-data-ingestion-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/index.ts
  - src/lib/date-utils.ts
  - src/lib/currency-utils.ts
autonomous: true

must_haves:
  truths:
    - "parseDate correctly handles Date objects, SheetJS serial numbers, ISO 8601, MM/DD/YYYY, text month formats, and 2-digit years"
    - "parseCurrency correctly handles plain numbers, $-prefixed, $$-prefixed, parenthetical negatives, European comma-decimal format, and empty/invalid inputs"
    - "Both functions return ParseResult<T> with value, error, and raw — never silently return null"
  artifacts:
    - path: "src/lib/date-utils.ts"
      provides: "parseDate() and excelSerialToDate() functions"
      exports: ["parseDate", "excelSerialToDate"]
      min_lines: 60
    - path: "src/lib/currency-utils.ts"
      provides: "parseCurrency() function"
      exports: ["parseCurrency"]
      min_lines: 40
    - path: "src/types/index.ts"
      provides: "ParseResult, ValidationSummary, RowError, SheetScore, CompositeField interfaces"
      contains: "interface ParseResult"
  key_links:
    - from: "src/lib/date-utils.ts"
      to: "src/types/index.ts"
      via: "import ParseResult"
      pattern: "import.*ParseResult.*from.*types"
    - from: "src/lib/currency-utils.ts"
      to: "src/types/index.ts"
      via: "import ParseResult"
      pattern: "import.*ParseResult.*from.*types"
---

<objective>
Add the foundational types and parsing utility functions that the entire ingestion pipeline depends on — ParseResult<T> pattern, robust date parsing, and robust currency parsing.

Purpose: INGEST-05 (date parsing) and INGEST-06 (currency parsing) are the lowest-level building blocks. Every row of data flows through these functions. Getting them right eliminates silent data loss — the #1 user trust killer.

Output: Three artifacts — extended types, date-utils module, currency-utils module — all pure functions with zero side effects, ready for consumption by validation and parsing modules in later plans.
</objective>

<execution_context>
@~/.cursor/get-shit-done/workflows/execute-plan.md
@~/.cursor/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-data-ingestion-pipeline/02-RESEARCH.md
@src/types/index.ts
@src/lib/parsing.ts
@src/lib/field-mapping.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend type definitions with ingestion pipeline interfaces</name>
  <files>src/types/index.ts</files>
  <action>
  Add the following new interfaces/types to `src/types/index.ts` AFTER the existing interfaces (do NOT modify existing interfaces yet — the Mappings fix happens in plan 02-04):

  1. **ParseResult<T>** — Generic parse-or-report result:
     ```typescript
     export interface ParseResult<T> {
       value: T | null;
       error: string | null;
       raw: string;
     }
     ```

  2. **RowError** — Per-row validation error:
     ```typescript
     export interface RowError {
       rowIndex: number;
       field: string;
       message: string;
       rawValue: string;
     }
     ```

  3. **ValidationSummary** — Aggregated validation output:
     ```typescript
     export interface ValidationSummary {
       totalRows: number;
       validRows: number;
       skippedRows: number;
       errors: RowError[];
       warnings: string[];
       unparsableDates: number;
       invalidAmounts: number;
       missingRequired: number;
     }
     ```

  4. **SheetScore** — Sheet ranking result:
     ```typescript
     export interface SheetScore {
       sheetName: string;
       score: number;
       reasons: string[];
     }
     ```

  5. **CompositeField** — Detected Key:Value column:
     ```typescript
     export interface CompositeField {
       columnIndex: number;
       headerName: string;
       extractedKeys: string[];
       keyFrequency: Map<string, number>;
     }
     ```

  Keep all existing interfaces untouched. Add these at the bottom of the file, before any closing comments.
  </action>
  <verify>
  Run `npx tsc --noEmit` — no type errors. Grep for `interface ParseResult` and `interface ValidationSummary` in `src/types/index.ts` to confirm they exist.
  </verify>
  <done>
  src/types/index.ts contains all 5 new interfaces (ParseResult, RowError, ValidationSummary, SheetScore, CompositeField) alongside the existing interfaces, and the project compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create robust date parsing utility</name>
  <files>src/lib/date-utils.ts</files>
  <action>
  Create `src/lib/date-utils.ts` with two exported functions:

  **`parseDate(input: unknown): ParseResult<Date>`** — Parse any date format seen in WC loss runs. Priority order:
  1. Already a Date object (from SheetJS `cellDates: true`) → validate with `isNaN(getTime())`, return as-is if valid
  2. SheetJS serial number (typeof number, range 1–200000) → call `excelSerialToDate()`
  3. Numeric string that looks like a serial (e.g., `"45000"`) → parse to number, call `excelSerialToDate()`
  4. ISO 8601 (`YYYY-MM-DD` or `YYYY-MM-DDTHH:mm:ss`) → extract parts with regex, construct with `new Date(y, m-1, d)`
  5. US format (`MM/DD/YYYY` or `MM-DD-YYYY`, supports 2-digit year) → extract with regex, handle 2-digit year (add 2000), construct explicitly
  6. Text month formats (`"Jan 15, 2024"`, `"15-Jan-2024"`) → detect month name regex, allow `new Date(string)` ONLY for text-month formats where it's reliable, validate year range 1990–2100
  7. All else → return `{ value: null, error: 'Unparseable date: "raw"', raw }`

  **CRITICAL:** NEVER use `new Date(string)` for numeric date formats (MM/DD/YYYY, DD/MM/YYYY, etc.) — it's locale-dependent and unreliable. Only use it for text-month formats where the month name disambiguates.

  **`excelSerialToDate(serial: number): ParseResult<Date>`** — Convert Excel 1900 date system serial to JS Date:
  - Serial 1 = Jan 1, 1900. Adjust for Lotus 1-2-3 bug (serial > 60 means subtract 1 because serial 60 = fake Feb 29, 1900).
  - Calculate: `adjustedSerial = serial > 60 ? serial - 1 : serial`, then `utcDays = floor(adjustedSerial - 1)`, epoch = `new Date(1900, 0, 1).getTime()`, result = `new Date(epoch + utcDays * 86400000)`.
  - Validate result with `isNaN(date.getTime())`.

  Import `ParseResult` from `../types`.

  This module must be pure functions with zero imports from state or DOM.
  </action>
  <verify>
  Run `npx tsc --noEmit` — no type errors. Manually verify in the dev console or a quick test:
  - `parseDate(new Date(2024, 0, 15))` → value is Jan 15, 2024
  - `parseDate(45000)` → value is a valid Date (around 2023)
  - `parseDate("01/15/2024")` → value is Jan 15, 2024
  - `parseDate("2024-01-15")` → value is Jan 15, 2024
  - `parseDate("Jan 15, 2024")` → value is Jan 15, 2024
  - `parseDate("")` → error is "Empty date value"
  - `parseDate("not a date")` → error is 'Unparseable date: "not a date"'
  </verify>
  <done>
  src/lib/date-utils.ts exports `parseDate` and `excelSerialToDate`. Both return `ParseResult<Date>`. No usage of `new Date(string)` for numeric formats. Handles all 6 format types listed above plus edge cases (empty, null, invalid).
  </done>
</task>

<task type="auto">
  <name>Task 3: Create robust currency parsing utility</name>
  <files>src/lib/currency-utils.ts</files>
  <action>
  Create `src/lib/currency-utils.ts` with one exported function:

  **`parseCurrency(input: unknown): ParseResult<number>`** — Parse currency values from carrier loss runs. Processing pipeline:
  1. If `typeof input === 'number'` → check `isFinite()`, return directly if valid
  2. Convert to string, trim. If empty/null/"-"/"$" → return error
  3. Detect parenthetical negatives: if matches `/^\(.*\)$/` → set `isNegative = true`, strip parens
  4. Detect leading minus: if starts with `-` → set `isNegative = true`, strip minus
  5. Strip currency symbols: remove leading `$` or `$$`, remove leading `USD` (case-insensitive)
  6. Detect European format: if string matches `/^[\d.]+,(\d{2})$/` (dots as thousands, comma before 2 decimal digits) → replace dots with empty, replace comma with period
  7. Otherwise US format: strip commas as thousands separators
  8. `parseFloat()` the result. If `isNaN` or `!isFinite` → return error
  9. Apply negative sign if detected, return `{ value, error: null, raw }`

  Import `ParseResult` from `../types`.

  This module must be pure functions with zero imports from state or DOM.

  **Edge cases to handle:**
  - `"($1,234.56)"` → -1234.56
  - `"-$1,234.56"` → -1234.56
  - `"$$1234"` → 1234 (some carriers use double dollar sign)
  - `"1.234,56"` → 1234.56 (European format)
  - `"1,234.56"` → 1234.56 (US format)
  - `0` → 0 (valid, not an error)
  - `""` → error
  </action>
  <verify>
  Run `npx tsc --noEmit` — no type errors. Manually verify:
  - `parseCurrency(1234.56)` → value is 1234.56
  - `parseCurrency("$1,234.56")` → value is 1234.56
  - `parseCurrency("($1,234.56)")` → value is -1234.56
  - `parseCurrency("1.234,56")` → value is 1234.56
  - `parseCurrency("$$1234")` → value is 1234
  - `parseCurrency("")` → error
  - `parseCurrency("N/A")` → error
  </verify>
  <done>
  src/lib/currency-utils.ts exports `parseCurrency` returning `ParseResult<number>`. Handles all listed edge cases: parenthetical negatives, double dollar signs, European formatting, plain numbers, and empty/invalid inputs. No silent null returns.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `src/types/index.ts` contains ParseResult, RowError, ValidationSummary, SheetScore, CompositeField interfaces
3. `src/lib/date-utils.ts` exports parseDate and excelSerialToDate
4. `src/lib/currency-utils.ts` exports parseCurrency
5. All three files import only from `../types` — no signal store, no DOM, no side effects
6. `npx wrangler dev` starts without errors (build succeeds)
</verification>

<success_criteria>
- ParseResult<T> pattern established as the universal return type for all parsing functions
- parseDate handles: Date objects, serial numbers, ISO 8601, US MM/DD/YYYY, text months, 2-digit years
- parseCurrency handles: raw numbers, $-prefix, $$-prefix, parenthetical negatives, European format
- Both functions NEVER silently return null — every failure has an error message with the raw input
- Zero new dependencies added
- Existing code unbroken (brownfield guard)
</success_criteria>

<output>
After completion, create `.planning/phases/02-data-ingestion-pipeline/02-01-SUMMARY.md`
</output>
