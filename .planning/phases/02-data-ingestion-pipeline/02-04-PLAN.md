---
phase: 02-data-ingestion-pipeline
plan: 04
type: execute
wave: 3
depends_on: ["02-02", "02-03"]
files_modified:
  - src/lib/parsing.ts
  - src/components/upload-page.tsx
autonomous: false

must_haves:
  truths:
    - "User uploads an AMIC-format workbook and the tool auto-selects the highest-scoring claims sheet instead of defaulting to the first sheet"
    - "User uploads a Standard Loss Run with 'Generic Field 1-8' columns and sees extracted composite dimensions (e.g., 'Nature of Injury') available for mapping"
    - "User sees a validation summary after mapping showing total rows, valid rows, skipped rows, unparsable dates count, invalid amounts count"
    - "Dates parse correctly via parseDate (MM/DD/YYYY, YYYY-MM-DD, serial numbers, text months) — no new Date(string) for numeric formats"
    - "Currency amounts parse correctly via parseCurrency (parenthetical negatives, $$ prefix, European format) — no simple replace/parseFloat"
    - "User can still manually override any auto-mapped column assignment"
  artifacts:
    - path: "src/lib/parsing.ts"
      provides: "Enhanced handleFileSelect with sheet ranking, handleSheetSelect with composite detection, applyMappingAndLoad with validation"
      exports: ["handleFileSelect", "handleSheetSelect", "applyMappingAndLoad"]
      min_lines: 200
    - path: "src/components/upload-page.tsx"
      provides: "Upload UI with sheet ranking display, composite field indicators, validation summary panel"
      exports: ["UploadPage"]
      min_lines: 200
  key_links:
    - from: "src/lib/parsing.ts"
      to: "src/lib/sheet-analysis.ts"
      via: "import rankSheets"
      pattern: "import.*rankSheets.*from.*sheet-analysis"
    - from: "src/lib/parsing.ts"
      to: "src/lib/composite-fields.ts"
      via: "import detectCompositeFields, extractCompositeValue"
      pattern: "import.*detectCompositeFields.*extractCompositeValue.*from.*composite-fields"
    - from: "src/lib/parsing.ts"
      to: "src/lib/field-mapping.ts"
      via: "import optionalFields for composite key matching"
      pattern: "import.*optionalFields.*from.*field-mapping"
    - from: "src/lib/parsing.ts"
      to: "src/lib/validation.ts"
      via: "import validateAndParseRow"
      pattern: "import.*validateAndParseRow.*from.*validation"
    - from: "src/lib/parsing.ts"
      to: "src/state/store.ts"
      via: "import validationSummary, sheetScores, compositeFields signals"
      pattern: "import.*validationSummary.*from.*store"
    - from: "src/components/upload-page.tsx"
      to: "src/state/store.ts"
      via: "import validationSummary, sheetScores, compositeFields for reactive display"
      pattern: "import.*validationSummary.*from.*store"
---

<objective>
Wire all the new utilities (date parsing, currency parsing, sheet analysis, composite fields, validation) into the existing parsing pipeline and upload UI — this is where the rubber meets the road.

Purpose: Plans 02-01 through 02-03 created standalone modules. This plan integrates them into the live parsing pipeline (parsing.ts) and updates the upload UI (upload-page.tsx) to surface sheet rankings, composite fields, and validation feedback to the user. This plan delivers the user-visible outcomes of the entire phase.

Output: An enhanced parsing.ts that uses smart sheet selection, robust parsing, and validation accumulation, plus an upload-page.tsx that shows sheet rankings, detected composite fields, and a validation summary panel.
</objective>

<execution_context>
@~/.cursor/get-shit-done/workflows/execute-plan.md
@~/.cursor/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-data-ingestion-pipeline/02-RESEARCH.md
@.planning/phases/02-data-ingestion-pipeline/02-01-SUMMARY.md
@.planning/phases/02-data-ingestion-pipeline/02-02-SUMMARY.md
@.planning/phases/02-data-ingestion-pipeline/02-03-SUMMARY.md
@src/lib/parsing.ts
@src/components/upload-page.tsx
@src/state/store.ts
@src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite parsing.ts to integrate all new utilities</name>
  <files>src/lib/parsing.ts</files>
  <action>
  Rewrite `src/lib/parsing.ts` to use all the new Phase 2 modules. The function signatures stay the same (brownfield guard) but internals change significantly.

  **New imports to add:**
  ```typescript
  import { rankSheets } from "./sheet-analysis";
  import { detectCompositeFields, extractCompositeValue } from "./composite-fields";
  import { validateAndParseRow, createEmptyValidationSummary, accumulateErrors } from "./validation";
  import { validationSummary, sheetScores, compositeFields as compositeFieldsSignal } from "../state/store";
  import { requiredFields, optionalFields } from "./field-mapping";
  ```

  **Changes to `handleFileSelect(file: File)`:**

  1. Change `XLSX.read(data, { type: "array" })` to `XLSX.read(data, { type: "array", cellDates: true })` — this makes SheetJS return native Date objects for date cells.

  2. After reading the workbook, call `rankSheets(wb)` to get scored sheets. Write the result to `sheetScores.value`.

  3. Instead of always selecting `sheetNames[0]`, select the highest-scoring sheet: `const bestSheet = scores[0]?.sheetName || sheetNames[0]`. Set `currentSheetName.value = bestSheet`.

  4. Update the status message to include sheet selection reasoning: `"Loaded workbook with N sheet(s). Auto-selected '${bestSheet}' (score: ${scores[0]?.score}). Select a sheet and map fields."`.

  5. Call `handleSheetSelect(bestSheet)` instead of `handleSheetSelect(sheetNames[0])`.

  **Changes to `handleSheetSelect(sheetName: string)`:**

  1. Change `sheet_to_json` options from `{ header: 1, raw: false }` to `{ header: 1, raw: true }` — this preserves native types (Date objects, numbers) instead of converting everything to formatted strings.

  2. After extracting sample data, detect composite fields in unmapped columns. Get the list of all column indices, then call `detectCompositeFields(allColumnIndices, result.headerRow, sampleData)`. Write the result to `compositeFieldsSignal.value`.

  3. If composite fields are detected, update the status message: `"... Detected ${compositeFields.length} composite field(s): ${compositeFields.map(cf => cf.headerName).join(', ')}."`.

  4. Return `{ sampleData, compositeFields: detectedCompositeFields }` instead of just `{ sampleData }`.

  **Changes to `applyMappingAndLoad(mappingOverrides: Record<string, number>)`:**

  This is the biggest change — replacing the inline parsing with the validation engine.

  1. **Fix the Mappings type mismatch bug.** Currently line ~222 does `newMappings[key] = headers[idx]` (assigns header string to what should be a number). Change to: `newMappings[key] = idx` — store the column INDEX, not the header name string. This fixes the `Mappings = Record<string, number>` type definition.

  2. **Change `sheet_to_json` call** to use `raw: true` instead of `raw: false`: `XLSX.utils.sheet_to_json(ws, { header: headers, range: headerRowIndex + 1, raw: true, defval: null })`.

  3. **Build composite overrides from detected composite fields.** After setting up `newMappings`, if `compositeFieldsSignal.value` has entries, match each composite field's extracted keys against the synonym hints in `optionalFields` to auto-map composite dimensions to canonical fields. Then for each row, extract the actual value:

     ```typescript
     // Build a lookup: canonical field name → { columnIndex, key } for composite fields
     const compositeFieldMap: Record<string, { columnIndex: number; key: string }> = {};
     for (const cf of compositeFieldsSignal.value) {
       for (const extractedKey of cf.extractedKeys) {
         const keyLower = extractedKey.toLowerCase();
         // Check each optional field's hints for a match
         for (const [fieldName, fieldDef] of Object.entries(optionalFields)) {
           if (fieldDef.hints.some((hint: string) => keyLower.includes(hint) || hint.includes(keyLower))) {
             // Only override if the field wasn't already mapped via column headers
             if (newMappings[fieldName] === undefined || newMappings[fieldName] === -1) {
               compositeFieldMap[fieldName] = { columnIndex: cf.columnIndex, key: extractedKey };
             }
             break;
           }
         }
       }
     }
     ```

  4. **Replace the `rawRows.forEach` parsing loop** with the validation engine:
     ```typescript
     const summary = createEmptyValidationSummary();
     summary.totalRows = rawRows.length;
     const out: CanonicalRecord[] = [];

     rawRows.forEach((row, idx) => {
       // Extract composite override values for this row
       const compositeOverrides: Record<string, string> = {};
       for (const [fieldName, { columnIndex, key }] of Object.entries(compositeFieldMap)) {
         const cellValue = row[headers[columnIndex]];
         if (cellValue != null) {
           const extracted = extractCompositeValue(String(cellValue), key);
           if (extracted) {
             compositeOverrides[fieldName] = extracted;
           }
         }
       }

       const { record, errors } = validateAndParseRow(
         row, newMappings, headers, idx + headerRowIndex + 2,  // 1-based row for user display
         Object.keys(compositeOverrides).length > 0 ? compositeOverrides : undefined
       );
       if (record) {
         out.push(record);
         summary.validRows++;
       } else {
         summary.skippedRows++;
       }
       if (errors.length > 0) {
         accumulateErrors(summary, errors);
       }
     });

     validationSummary.value = summary;
     ```

  5. **Update the status message** to include validation info:
     ```
     `Parsed ${out.length} valid row(s) of ${rawRows.length} total. ${summary.skippedRows} row(s) skipped.`
     + (summary.unparsableDates > 0 ? ` ${summary.unparsableDates} unparsable date(s).` : '')
     + (summary.invalidAmounts > 0 ? ` ${summary.invalidAmounts} invalid amount(s).` : '')
     ```

  6. **Keep `populateSiteFilter` and `populateAdjustmentsFromData` calls** at the end — these are unchanged.

  **Critical brownfield guards:**
  - `handleFileSelect`, `handleSheetSelect`, `applyMappingAndLoad` keep the same function signatures
  - `populateSiteFilter` and `populateAdjustmentsFromData` are unchanged
  - `getFilteredData` is unchanged
  - The module still exports the same public API
  </action>
  <verify>
  Run `npx tsc --noEmit` — no type errors. Run `npx wrangler dev` and verify:
  1. Upload any Excel file → the status message includes sheet selection info
  2. Auto-mapping still works for standard column names
  3. After "Apply mapping & load data", the status shows row counts including skipped rows
  4. If there are parse errors, they're mentioned in the status (not silently dropped)
  </verify>
  <done>
  parsing.ts uses cellDates:true, rankSheets for smart sheet selection, detectCompositeFields for composite detection, validateAndParseRow for row-level validation, and stores validation results in the signal store. Composite keys (e.g., "Nature of Injury") are auto-matched against optionalFields synonym hints and their extracted values are passed as compositeOverrides to validateAndParseRow. The Mappings type bug is fixed (stores indices, not header strings). Function signatures unchanged — existing UI code calling these functions still works.
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance upload page UI with sheet ranking, composite fields, and validation summary</name>
  <files>src/components/upload-page.tsx</files>
  <action>
  Update `src/components/upload-page.tsx` to surface the new Phase 2 capabilities to the user.

  **New imports:**
  Add to existing store imports: `validationSummary`, `sheetScores`, `compositeFields`, `hasValidationErrors`.

  **Changes to the sheet selector (Column 1: Upload card):**

  1. After the sheet `<select>` dropdown, if `sheetScores.value.length > 1`, show a small info line:
     ```tsx
     {sheetScores.value.length > 1 && (
       <p class="small" style={{ marginTop: '4px', color: '#666' }}>
         Auto-selected best match.{' '}
         {sheetScores.value[0] && (
           <span title={sheetScores.value[0].reasons.join(', ')}>
             Score: {sheetScores.value[0].score}
           </span>
         )}
       </p>
     )}
     ```

  2. In the sheet `<select>`, append the score to each option label for transparency:
     ```tsx
     sheets.map((name) => {
       const scoreObj = sheetScores.value.find(s => s.sheetName === name);
       const scoreLabel = scoreObj ? ` (score: ${scoreObj.score})` : '';
       return (
         <option key={name} value={name}>
           {name}{scoreLabel}
         </option>
       );
     })
     ```

  **Changes to the mapping table (Column 2: Map columns card):**

  1. If `compositeFields.value.length > 0`, show a notice above the mapping table:
     ```tsx
     {compositeFields.value.length > 0 && (
       <div class="status" style={{ marginBottom: '8px', background: '#f0f7ff', border: '1px solid #cce0ff' }}>
         <strong>Composite fields detected:</strong>{' '}
         {compositeFields.value.map(cf => (
           <span key={cf.columnIndex}>
             {cf.headerName} → {cf.extractedKeys.join(', ')}
           </span>
         )).reduce((prev, curr) => <>{prev}; {curr}</>)}
       </div>
     )}
     ```

  **Changes to the bottom area (after the "Apply mapping" button):**

  1. Replace the simple `"{N} rows loaded"` span with a validation summary panel when `validationSummary.value` exists:
     ```tsx
     {validationSummary.value && (
       <div class={`status ${validationSummary.value.skippedRows > 0 ? 'warn' : 'ok'}`}
            style={{ marginTop: '8px' }}>
         <strong>{validationSummary.value.validRows}</strong> valid rows
         of {validationSummary.value.totalRows} total.
         {validationSummary.value.skippedRows > 0 && (
           <span>
             {' '}<strong>{validationSummary.value.skippedRows}</strong> skipped
             {validationSummary.value.unparsableDates > 0 && (
               <span> ({validationSummary.value.unparsableDates} unparsable dates)</span>
             )}
             {validationSummary.value.invalidAmounts > 0 && (
               <span> ({validationSummary.value.invalidAmounts} invalid amounts)</span>
             )}
             {validationSummary.value.missingRequired > 0 && (
               <span> ({validationSummary.value.missingRequired} missing required fields)</span>
             )}
           </span>
         )}
       </div>
     )}
     ```

  2. Keep the existing `canonicalData.value.length > 0` check as a fallback, but prefer the validation summary when available.

  **Update `onSheetChange` handler:**
  The `handleSheetSelect` now returns `{ sampleData, compositeFields }` — update the handler to capture this:
  ```typescript
  function onSheetChange(e: Event) {
    const select = e.target as HTMLSelectElement;
    overrides.value = {};
    const result = handleSheetSelect(select.value);
    sampleData.value = result?.sampleData ?? null;
    // compositeFields are written to store signal by handleSheetSelect directly
  }
  ```

  **Styling note:** Use inline styles for now (matching existing patterns). The `status` CSS class already exists from Phase 1. Add `warn` variant with yellow/amber tones for validation warnings. If a `.status.warn` class doesn't exist in CSS, add a simple inline style: `background: '#fff8e1', border: '1px solid #ffcc02'`.

  **Brownfield guard:**
  - Manual override dropdowns still work exactly as before
  - The "Apply mapping & load data" button still calls `applyMappingAndLoad(finalMapping)`
  - Navigation to page 2 on success still works
  - The mapping table still shows all fields (required + optional) with auto-detected + manual override
  </action>
  <verify>
  Run `npx tsc --noEmit` — no type errors. Run `npx wrangler dev` and verify the full upload flow:
  1. Upload an Excel file → sheet selector shows scores next to sheet names
  2. If multi-sheet, the best sheet is auto-selected (not necessarily the first)
  3. Mapping table appears with auto-detected column matches
  4. If composite fields exist in the file, a blue notice shows detected keys
  5. Click "Apply mapping & load data" → validation summary appears showing valid/skipped row counts
  6. If rows were skipped, the summary shows categorized error counts (dates, amounts, required)
  7. Manual override dropdowns still work
  8. Successful mapping still navigates to page 2
  </verify>
  <done>
  upload-page.tsx shows sheet scores in the sheet selector dropdown, displays composite field detection notices, and renders a validation summary with categorized error counts after data loading. Users can see exactly what succeeded and what failed — transparent validation feedback that builds trust.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete data ingestion pipeline with smart sheet selection, robust date/currency parsing, composite field detection, expanded column matching, and validation feedback UI</what-built>
  <how-to-verify>
  Run `npx wrangler dev` and test with available Excel files:

  1. **Single-sheet file test:**
     - Upload any standard loss run file
     - Verify columns auto-map correctly (especially with expanded synonyms)
     - Click "Apply mapping & load data"
     - Verify validation summary shows row counts
     - Verify you can proceed to page 2 and see data

  2. **Multi-sheet file test (if available):**
     - Upload a workbook with multiple sheets
     - Verify the sheet selector shows scores next to sheet names
     - Verify the best sheet is auto-selected
     - Verify you can switch sheets manually

  3. **Validation feedback test:**
     - If any rows have parse errors, verify the summary shows skipped counts with categories
     - Verify the summary distinguishes between unparsable dates, invalid amounts, and missing fields

  4. **Brownfield check:**
     - The full wizard flow (upload → map → adjust → results) still works end-to-end
     - Manual column overrides still work
     - No regressions in existing functionality
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npx wrangler dev` starts without errors
3. File upload → smart sheet selection (not just first sheet)
4. Column auto-mapping works with expanded synonyms
5. Validation summary appears after "Apply mapping & load data"
6. Sheet scores visible in dropdown
7. Composite field detection notice shows when applicable
8. Full wizard flow works end-to-end (brownfield guard)
9. Manual override dropdowns still function correctly
</verification>

<success_criteria>
- User uploads AMIC-format file → tool auto-selects the correct claims sheet (INGEST-03)
- User uploads Standard Loss Run with Generic Fields → sees extracted dimensions (INGEST-02)
- User sees validation summary with categorized error counts (INGEST-04)
- Dates parse correctly regardless of format (INGEST-05 integration)
- Currency amounts parse correctly regardless of format (INGEST-06 integration)
- Column auto-mapping improved with expanded synonyms (INGEST-01 integration)
- Manual overrides still work (brownfield guard from Phase 1)
- No silent row drops — every skipped row is accounted for
</success_criteria>

<output>
After completion, create `.planning/phases/02-data-ingestion-pipeline/02-04-SUMMARY.md`
</output>
