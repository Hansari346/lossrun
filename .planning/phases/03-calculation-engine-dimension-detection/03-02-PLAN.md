---
phase: 03-calculation-engine-dimension-detection
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/state/store.ts
  - src/lib/calculations.ts
  - src/components/dimension-panel.tsx
  - src/components/adjustments-page.tsx
  - src/components/results-page.tsx
autonomous: false

must_haves:
  truths:
    - "After data upload, detected dimensions appear as a panel on the adjustments page showing availability with coverage percentages"
    - "User can toggle individual dimensions on/off via checkboxes in the dimension panel"
    - "Changing an adjustment slider or filter recalculates results instantly without clicking a Calculate button"
    - "Preset buttons (Conservative/Balanced/Aggressive) apply changes in a single batch — no intermediate flicker"
    - "Results page reads from the reactive results computed — no stale data possible"
    - "Site filter changes immediately reflect in results"
  artifacts:
    - path: "src/state/store.ts"
      provides: "detectedDimensions computed, dimensionOverrides signal, activeDimensions computed, reactive results computed"
      contains: "detectedDimensions"
    - path: "src/components/dimension-panel.tsx"
      provides: "DimensionPanel component showing detected dimensions with toggle controls"
      exports: ["DimensionPanel"]
    - path: "src/lib/calculations.ts"
      provides: "Pure function module — calculateResults() orchestrator and store imports removed"
      contains: "computeResults"
    - path: "src/components/adjustments-page.tsx"
      provides: "Updated adjustments page with dimension panel, reactive navigation, batch preset application"
      contains: "DimensionPanel"
    - path: "src/components/results-page.tsx"
      provides: "Results page reading from reactive results signal"
      contains: "results"
  key_links:
    - from: "src/state/store.ts"
      to: "src/lib/dimensions.ts"
      via: "imports detectDimensions for computed signal"
      pattern: "import.*detectDimensions.*from.*dimensions"
    - from: "src/state/store.ts"
      to: "src/lib/calculations.ts"
      via: "imports computeResults + getFilteredData for reactive results"
      pattern: "import.*computeResults.*from.*calculations"
    - from: "src/components/dimension-panel.tsx"
      to: "src/state/store.ts"
      via: "reads detectedDimensions, writes dimensionOverrides"
      pattern: "detectedDimensions|dimensionOverrides"
    - from: "src/components/adjustments-page.tsx"
      to: "src/state/store.ts"
      via: "reads activeDimensions, navigates using currentPage, uses batch()"
      pattern: "activeDimensions|batch"
    - from: "src/components/results-page.tsx"
      to: "src/state/store.ts"
      via: "reads reactive results computed signal"
      pattern: "results\\.value"
---

<objective>
Wire the dimension detection and calculation engine into reactive Preact Signals, build the user-facing dimension confirmation panel, and update the adjustments and results pages to use reactive computation.

Purpose: This plan completes the Phase 3 requirements by: (1) making calculations reactive via computed signals so results update instantly when any input changes (INFRA-04/05), (2) building the dimension detection signal chain so dimensions are detected once when data loads and user overrides are merged (DIM-01/02), (3) providing the dimension confirmation UI (DIM-03), and (4) ensuring all downstream consumers (results page, future charts/exports) read from the same reactive Results Object.

Output: Updated store with reactive signals, new DimensionPanel component, updated adjustments and results pages.
</objective>

<execution_context>
@~/.cursor/get-shit-done/workflows/execute-plan.md
@~/.cursor/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-calculation-engine-dimension-detection/03-RESEARCH.md
@.planning/phases/03-calculation-engine-dimension-detection/03-01-SUMMARY.md

@src/types/index.ts
@src/lib/dimensions.ts
@src/lib/calculations.ts
@src/state/store.ts
@src/components/adjustments-page.tsx
@src/components/results-page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Reactive store signals, remove dead orchestrator, and dimension panel component</name>
  <files>src/state/store.ts, src/lib/calculations.ts, src/components/dimension-panel.tsx</files>
  <action>
  **1. Update src/state/store.ts:**

  Add imports at top:
  ```typescript
  import { signal, computed, batch } from "@preact/signals";
  import { detectDimensions, DIMENSION_KEYS } from "../lib/dimensions";
  import type { DimensionKey, DimensionAvailability } from "../types";
  import { computeResults, getFilteredData } from "../lib/calculations";
  ```

  Add new dimension signals after the existing `compositeFields` signal:

  ```typescript
  // === Dimension detection state ===
  export const dimensionOverrides = signal<Partial<Record<DimensionKey, boolean>>>({});

  // === Derived: dimension detection (recomputes only when canonicalData changes) ===
  export const detectedDimensions = computed<DimensionAvailability | null>(() => {
    const data = canonicalData.value;
    if (data.length === 0) return null;
    return detectDimensions(data);
  });

  // === Derived: active dimensions (merges detected + user overrides) ===
  export const activeDimensions = computed<Record<DimensionKey, boolean>>(() => {
    const detected = detectedDimensions.value;
    if (!detected) {
      return Object.fromEntries(DIMENSION_KEYS.map((k) => [k, false])) as Record<DimensionKey, boolean>;
    }
    const overrides = dimensionOverrides.value;
    return Object.fromEntries(
      DIMENSION_KEYS.map((k) => [k, overrides[k] ?? detected[k].available])
    ) as Record<DimensionKey, boolean>;
  });
  ```

  **Replace the existing `results` signal** (currently `export const results = signal<CalculationResults | null>(null);`) with a reactive computed:

  ```typescript
  // === Reactive results — auto-recomputes when inputs change ===
  export const results = computed<CalculationResults | null>(() => {
    const data = canonicalData.value;
    if (data.length === 0) return null;

    const filtered = getFilteredData(data, selectedSite.value);
    const params = adjustments.value;
    const dims = activeDimensions.value;

    try {
      return computeResults(filtered, params, dims);
    } catch (e) {
      console.error("Calculation error:", e);
      return null;
    }
  });
  ```

  **CRITICAL ordering:** The `results` computed must be defined AFTER `canonicalData`, `selectedSite`, `adjustments`, and `activeDimensions` signals. Move the `results` definition to after the `activeDimensions` computed.

  **Update resetState():**
  - Remove `results.value = null;` (results is now a computed — read-only, can't assign)
  - Add `dimensionOverrides.value = {};` to clear overrides on reset
  - The results computed will automatically return null when canonicalData is reset to []

  **Remove `isCalculating` signal:** Since the reactive computed replaces the imperative `calculateResults()`, the `isCalculating` signal is dead state (never written to). Remove it:
  - Remove `export const isCalculating = signal<boolean>(false);`
  - Remove `isCalculating.value = false;` from `resetState()` if present

  **Re-export batch from @preact/signals** for use by consumer components:
  ```typescript
  export { batch } from "@preact/signals";
  ```

  **3. Remove dead `calculateResults()` orchestrator from src/lib/calculations.ts:**

  The imperative `calculateResults()` function at the bottom of `calculations.ts` writes `results.value = result;`, but `results` is now a read-only `computed` — this would cause a TypeScript compilation error. Since the reactive computed chain in `store.ts` completely replaces this function:

  - Remove the `calculateResults()` function entirely (the orchestrator wrapper, NOT `computeResults()`)
  - Remove the store signal imports it used: `results`, `isCalculating`, `canonicalData`, `adjustments`, `selectedSite` from `"../state/store"`
  - Keep ALL pure function exports: `getFilteredData`, `annualizeInjuries`, `calculateObservationCost`, `getPresetValues`, `computeResults`
  - The file should have ZERO imports from `../state/store` after this change — it becomes a pure function module

  **4. Create src/components/dimension-panel.tsx:**

  A Preact component that shows detected dimensions with toggle controls. Design:

  ```tsx
  import { detectedDimensions, dimensionOverrides, activeDimensions } from "../state/store";
  import { DIMENSION_KEYS } from "../lib/dimensions";
  import type { DimensionKey } from "../types";

  /** Human-readable labels for dimension keys */
  const DIMENSION_LABELS: Record<DimensionKey, string> = {
    cause_of_loss: "Cause of Loss",
    body_part: "Body Part",
    claim_category: "Claim Category",
    lost_days: "Lost Time / Days",
    site_comparison: "Site Comparison",
    loss_description: "Loss Description",
  };

  export function DimensionPanel() {
    const detected = detectedDimensions.value;
    if (!detected) return null; // No data loaded yet

    const active = activeDimensions.value;

    const toggleDimension = (key: DimensionKey) => {
      const current = dimensionOverrides.value;
      const currentActive = active[key];
      dimensionOverrides.value = { ...current, [key]: !currentActive };
    };

    return (
      <div class="card" style={{ marginBottom: "16px" }}>
        <div class="card-header">
          <h2 style={{ fontSize: "1rem", margin: 0 }}>Detected Dimensions</h2>
        </div>
        <p style={{ fontSize: "0.875rem", color: "#64748B", margin: "0 0 12px" }}>
          We detected these analysis dimensions in your data. Toggle to include or exclude from analysis.
        </p>
        <div style={{ display: "grid", gridTemplateColumns: "repeat(auto-fill, minmax(220px, 1fr))", gap: "8px" }}>
          {DIMENSION_KEYS.map((key) => {
            const info = detected[key];
            const isActive = active[key];
            const coverage = Math.round(info.coverage * 100);
            return (
              <label
                key={key}
                style={{
                  display: "flex",
                  alignItems: "center",
                  gap: "8px",
                  padding: "8px 12px",
                  borderRadius: "8px",
                  background: isActive ? "var(--card-bg, #f8fafc)" : "transparent",
                  border: `1px solid ${isActive ? "var(--accent, #6366f1)" : "#e2e8f0"}`,
                  cursor: "pointer",
                  transition: "all 0.15s",
                }}
              >
                <input
                  type="checkbox"
                  checked={isActive}
                  onChange={() => toggleDimension(key)}
                  style={{ accentColor: "var(--accent, #6366f1)" }}
                />
                <div>
                  <div style={{ fontWeight: 500, fontSize: "0.875rem" }}>
                    {DIMENSION_LABELS[key]}
                  </div>
                  <div style={{ fontSize: "0.75rem", color: "#94a3b8" }}>
                    {info.available
                      ? `${coverage}% populated · ${info.distinctValues} values`
                      : info.recordCount === 0
                        ? "No data found"
                        : `${coverage}% populated (below threshold)`}
                  </div>
                </div>
              </label>
            );
          })}
        </div>
      </div>
    );
  }
  ```

  Style notes:
  - Use the existing `.card` and `.card-header` CSS classes for visual consistency
  - Grid layout for the dimension toggles — responsive, wraps on narrow screens
  - Each dimension shows: checkbox, label, coverage info
  - Active dimensions have a subtle accent border
  - Use existing CSS custom properties (--accent, --card-bg, --fg) where available, with sensible fallbacks
  </action>
  <verify>
  Run `npx tsc --noEmit` — no type errors.
  Verify store.ts exports: detectedDimensions, dimensionOverrides, activeDimensions, results (now computed), batch.
  Verify dimension-panel.tsx imports from store and dimensions module only.
  </verify>
  <done>
  - store.ts has detectedDimensions (computed from canonicalData), dimensionOverrides (signal), activeDimensions (computed merging detected + overrides)
  - results is now a computed signal that auto-recomputes on canonicalData/adjustments/selectedSite/activeDimensions changes
  - isCalculating signal removed (dead state)
  - resetState() clears dimensionOverrides and no longer tries to write to results or isCalculating
  - calculations.ts has calculateResults() removed — zero store imports, pure function module only
  - DimensionPanel component renders dimension toggles with coverage info
  - batch is re-exported from store for consumer use
  </done>
</task>

<task type="auto">
  <name>Task 2: Update adjustments page and results page for reactive flow</name>
  <files>src/components/adjustments-page.tsx, src/components/results-page.tsx</files>
  <action>
  **1. Update src/components/adjustments-page.tsx:**

  **Import changes:**
  - Remove `calculateResults` from `../lib/calculations` import (no longer needed — results are reactive)
  - Add `import { DimensionPanel } from "./dimension-panel";`
  - Add `batch` to the store import: `import { adjustments, currentPage, canonicalData, selectedSite, availableSites, batch } from "../state/store";`
  - Keep `getPresetValues`, `calculateObservationCost`, `getFilteredData` imports from calculations

  **Update applyPreset() to use batch():**
  ```typescript
  const applyPreset = (preset: "conservative" | "balanced" | "aggressive") => {
    activePreset.value = preset;
    const vals = getPresetValues(preset);
    batch(() => {
      adjustments.value = { ...adjustments.value, ...vals };
    });
  };
  ```

  **Update onCalculate handler:**
  Replace the current implementation that calls `calculateResults()` then navigates:
  ```typescript
  const onCalculate = () => {
    // Results are computed reactively — just navigate
    currentPage.value = 3;
  };
  ```

  **Add DimensionPanel to the JSX:**
  Insert `<DimensionPanel />` at the top of the return JSX, right after the intro paragraph and BEFORE the site filter card:
  ```tsx
  <p>Adjust calculation assumptions and parameters...</p>

  {/* Detected Dimensions */}
  <DimensionPanel />

  {/* Site filter */}
  {availableSites.value.length > 1 && ( ... )}
  ```

  **Update "Calculate" button label** since results are now reactive — change "Calculate & View Results →" to "View Results →" (calculation already happened reactively).

  **2. Update src/components/results-page.tsx:**

  The results page currently reads `results.value` which will continue to work since computed signals expose `.value` the same way writable signals do. The main changes are minimal:

  - Remove the `isCalculating` import if present (reactive results don't need a loading flag for this use case)
  - The `useEffect` with `[results.value]` dependency will continue to work correctly — it fires whenever the computed value changes
  - The null check `if (!r)` will still handle the no-data case correctly

  The results page should remain largely unchanged. The reactive results signal is a drop-in replacement. Verify it works by:
  1. Confirming the `results` import from store still works (same export name, now computed instead of signal)
  2. Confirming `results.value` reads produce the same CalculationResults shape (plus the new `dimensions` field)

  **Optional enhancement (if the existing useEffect pattern causes stale chart state):** The chart drawing useEffect may need updating since results now change automatically when adjustments change. If charts double-render or show stale data, add cleanup logic. But the existing `return () => { destroyCharts(instances); }` cleanup should handle this.

  **IMPORTANT:** Do NOT remove or change any existing chart rendering logic. Phase 4 handles adaptive chart rendering. In this plan, all charts still render regardless of dimension availability — the `dimensions` metadata is available on the results object for Phase 4 to consume.
  </action>
  <verify>
  1. Run `npx tsc --noEmit` — no type errors
  2. Run `npx wrangler dev` and test the full flow:
     a. Upload an Excel file with loss run data
     b. Verify the Detected Dimensions panel appears on the adjustments page
     c. Toggle a dimension off (e.g., uncheck "Cause of Loss") and verify it's reflected
     d. Click "View Results" — results page renders with charts
     e. Navigate back to adjustments, change a slider, navigate to results — results updated without explicit recalculation
     f. Change site filter — results update accordingly
     g. Apply a preset (Conservative/Balanced/Aggressive) — no flicker, single update
  3. Verify `npx wrangler deploy` succeeds (production build)
  </verify>
  <done>
  - Adjustments page shows DimensionPanel after data upload
  - Adjustments page uses batch() for preset application
  - "Calculate & View Results" button replaced with "View Results" (calculation is reactive)
  - Results page reads from reactive computed results — always up-to-date
  - Full wizard flow works: Upload → Adjustments (with dimensions) → Results
  - No regressions in existing chart rendering or KPI display
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
  Complete Phase 3: Dimension detection, reactive calculation engine, and dimension confirmation UI.
  
  - Detected Dimensions panel on the adjustments page showing which analysis dimensions are available in uploaded data
  - Toggle controls to enable/disable individual dimensions
  - Reactive results that update instantly when adjustments change (no "Calculate" button needed)
  - Dimension metadata flowing through to the results object
  </what-built>
  <how-to-verify>
  1. Run `npx wrangler dev` and open the app in browser
  2. Upload an Excel loss run file
  3. On the Adjustments page, verify:
     - A "Detected Dimensions" panel appears at the top
     - Each dimension shows a checkbox, label, and coverage info (e.g., "85% populated · 12 values")
     - Toggling a dimension on/off updates the checkbox state
  4. Click "View Results" — verify charts and KPI tiles render correctly
  5. Go back to Adjustments, change WC Reduction to 50 — navigate to Results and verify the numbers changed without clicking a separate "Calculate" button
  6. Test preset buttons (Conservative/Balanced/Aggressive) — no flicker, smooth update
  7. If multiple sites exist, test the site filter — results should update when site changes
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npx wrangler dev` — full wizard flow works end-to-end
3. Detected Dimensions panel visible on adjustments page after data upload
4. Dimension toggles work — checking/unchecking dimensions is reflected in state
5. Results are reactive — changing adjustments/site/dimensions updates results without explicit recalculation
6. Presets apply without flicker (batch)
7. Results page shows correct KPI values and charts
8. `npx wrangler deploy` succeeds
</verification>

<success_criteria>
- INFRA-04: computeResults() remains a pure function; reactivity wrapper is in store.ts computed
- INFRA-05: All consumers read from the same reactive `results` computed signal
- DIM-01: After data upload, dimensions auto-detected based on field population rates
- DIM-02: CalculationResults carries `dimensions` metadata; breakdowns gated by active dimensions
- DIM-03: User sees Detected Dimensions panel with coverage info and toggle controls
- Zero regressions in existing wizard flow, KPI tiles, chart rendering, or PPT export
</success_criteria>

<output>
After completion, create `.planning/phases/03-calculation-engine-dimension-detection/03-02-SUMMARY.md`
</output>
