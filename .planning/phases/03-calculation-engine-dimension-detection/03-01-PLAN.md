---
phase: 03-calculation-engine-dimension-detection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/index.ts
  - src/lib/dimensions.ts
  - src/lib/calculations.ts
autonomous: true

must_haves:
  truths:
    - "detectDimensions() returns accurate availability for all 6 dimension keys based on actual data population"
    - "computeResults() conditionally skips breakdowns for inactive dimensions, returning empty arrays"
    - "CalculationResults includes a dimensions field that downstream consumers can check"
    - "Existing computeResults() behavior is preserved when no dimensions param is passed (backward compatible)"
  artifacts:
    - path: "src/types/index.ts"
      provides: "DimensionKey, DimensionInfo, DimensionAvailability types, dimensions field on CalculationResults"
      contains: "DimensionKey"
    - path: "src/lib/dimensions.ts"
      provides: "detectDimensions() pure function, DIMENSION_KEYS constant, isPopulated helper"
      exports: ["detectDimensions", "DIMENSION_KEYS", "DimensionKey", "DimensionInfo", "DimensionAvailability"]
    - path: "src/lib/calculations.ts"
      provides: "Dimension-aware computeResults() with optional dims parameter"
      contains: "dimensions"
  key_links:
    - from: "src/lib/dimensions.ts"
      to: "src/types/index.ts"
      via: "imports CanonicalRecord type"
      pattern: "import.*CanonicalRecord.*from.*types"
    - from: "src/lib/calculations.ts"
      to: "src/lib/dimensions.ts"
      via: "imports DimensionKey type for dims parameter"
      pattern: "import.*DimensionKey.*from.*dimensions"
    - from: "src/lib/calculations.ts"
      to: "CalculationResults.dimensions"
      via: "populates dimensions field in return object"
      pattern: "dimensions:\\s*dims"
---

<objective>
Add dimension detection types and pure functions, then make the calculation engine dimension-aware.

Purpose: This plan establishes the foundational types and pure-function logic that all reactive state and UI will build on. The dimension detection function inspects canonical data to determine which optional analysis dimensions (cause of loss, body part, claim category, lost days, site comparison, loss description) have meaningful data. The calculation engine is then enhanced to conditionally skip breakdowns for unavailable dimensions, and to carry dimension metadata in the results object for downstream consumers (DIM-02 keystone).

Output: Three files — extended types, new dimensions module, enhanced calculations module.
</objective>

<execution_context>
@~/.cursor/get-shit-done/workflows/execute-plan.md
@~/.cursor/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-calculation-engine-dimension-detection/03-RESEARCH.md

@src/types/index.ts
@src/lib/calculations.ts
@src/state/store.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Dimension types and detection module</name>
  <files>src/types/index.ts, src/lib/dimensions.ts</files>
  <action>
  **1. Extend src/types/index.ts:**

  Add after the existing type exports (before the `// ── Ingestion Pipeline Types` section):

  ```typescript
  // ── Dimension Detection Types ──────────────────────────────────────────

  /** All possible analysis dimensions beyond the 3 required fields */
  export type DimensionKey =
    | "cause_of_loss"
    | "body_part"
    | "claim_category"
    | "lost_days"
    | "site_comparison"
    | "loss_description";

  export interface DimensionInfo {
    available: boolean;
    recordCount: number;
    totalRecords: number;
    coverage: number;        // recordCount / totalRecords (0-1)
    distinctValues: number;  // cardinality of the field's values
  }

  export type DimensionAvailability = Record<DimensionKey, DimensionInfo>;
  ```

  Add a `dimensions` field to the `CalculationResults` interface, after the `siteComparison` field:

  ```typescript
  // Dimension metadata — consumers check this before rendering
  dimensions: Record<DimensionKey, boolean>;
  ```

  **2. Create src/lib/dimensions.ts:**

  Pure module — no signal imports, no DOM access. Contains:

  - `DIMENSION_KEYS` constant array (as const) of all 6 DimensionKey values
  - `isPopulated(key, row)` helper — switch on key to check if the row has meaningful data for that dimension:
    - `cause_of_loss`: `!!row.cause_of_loss?.trim()`
    - `body_part`: `!!row.body_part?.trim()`
    - `claim_category`: `!!row.claim_category?.trim()`
    - `lost_days`: `row.lost_days !== undefined && row.lost_days > 0`
    - `loss_description`: `!!row.loss_description?.trim()`
    - `site_comparison`: `!!row.site_name?.trim()`
  - `detectDimensions(data: CanonicalRecord[]): DimensionAvailability` — iterates DIMENSION_KEYS, for each:
    - Count populated records using `isPopulated()`
    - Count distinct values (Set of lowercased trimmed string values; for lost_days use String(value))
    - Threshold: `available = true` when `populated >= max(3, ceil(total * 0.05))` — EXCEPT `site_comparison` requires `distinctValues > 1` (more than 1 unique site)
    - Handle empty data: return all dimensions unavailable with zero counts

  Import only `CanonicalRecord` from `../types`. Re-export the dimension types for convenience.

  **Critical:** Do NOT import any signals or store modules. This must be a pure function module.
  </action>
  <verify>
  Run `npx tsc --noEmit` — no type errors.
  Verify src/lib/dimensions.ts exports detectDimensions, DIMENSION_KEYS, and imports only from ../types.
  </verify>
  <done>
  - DimensionKey, DimensionInfo, DimensionAvailability types exist in types/index.ts
  - CalculationResults has a `dimensions: Record<DimensionKey, boolean>` field
  - src/lib/dimensions.ts exists with detectDimensions() pure function
  - detectDimensions([]) returns all dimensions unavailable
  - detectDimensions(dataWith100CauseRecords) returns cause_of_loss.available === true
  - No signal or DOM imports in dimensions.ts
  </done>
</task>

<task type="auto">
  <name>Task 2: Make computeResults() dimension-aware</name>
  <files>src/lib/calculations.ts</files>
  <action>
  **1. Add import for DimensionKey type:**

  ```typescript
  import type { DimensionKey } from "../types";
  ```

  **2. Update computeResults() signature:**

  Add an optional third parameter:

  ```typescript
  export function computeResults(
    data: CanonicalRecord[],
    params: AdjustmentParams,
    dimensions?: Record<DimensionKey, boolean>,
  ): CalculationResults {
  ```

  **3. Gate breakdown computations:**

  Replace the unconditional breakdown section (currently around lines 423-427):

  ```typescript
  // Current (always computes):
  const categoryBreakdown = buildCategoryBreakdown(data, "claim_category");
  const bodyPartBreakdown = buildCategoryBreakdown(data, "body_part");
  const causeBreakdown = buildCategoryBreakdown(data, "cause_of_loss");
  const siteComparison = buildSiteComparison(data);
  ```

  With dimension-gated version:

  ```typescript
  // Default: all dimensions active (backward compatibility when no dims passed)
  const dims = dimensions ?? {
    cause_of_loss: true,
    body_part: true,
    claim_category: true,
    lost_days: true,
    site_comparison: true,
    loss_description: true,
  };

  const yearlyData = buildYearlyData(data); // always computed (core)
  const categoryBreakdown = dims.claim_category
    ? buildCategoryBreakdown(data, "claim_category") : [];
  const bodyPartBreakdown = dims.body_part
    ? buildCategoryBreakdown(data, "body_part") : [];
  const causeBreakdown = dims.cause_of_loss
    ? buildCategoryBreakdown(data, "cause_of_loss") : [];
  const siteComparison = dims.site_comparison
    ? buildSiteComparison(data) : [];
  ```

  **4. Add dimensions to return object:**

  In the return statement, add after `siteComparison`:

  ```typescript
  // Dimension metadata for downstream consumers (DIM-02)
  dimensions: dims,
  ```

  **5. Keep calculateResults() working:**

  The imperative `calculateResults()` orchestrator at the bottom of the file should continue to work as-is — it calls `computeResults(data, params)` without the third arg, which will use the default (all true). This maintains backward compatibility until Plan 02 replaces it with reactive signals.

  **IMPORTANT:** Do NOT change the `calculateResults()` function in this task. It will be updated in Plan 02.
  **IMPORTANT:** The `yearlyData` line already exists above the breakdowns — make sure not to duplicate it. Move the existing `const yearlyData = buildYearlyData(data);` line to be part of the gated section, OR leave it in place if it's already above the breakdown lines. The key is: yearlyData is always computed, the other 4 are gated.
  </action>
  <verify>
  Run `npx tsc --noEmit` — no type errors.
  Verify `computeResults(data, params)` still works without the third arg (backward compat).
  Verify `computeResults(data, params, { cause_of_loss: false, body_part: false, claim_category: false, lost_days: false, site_comparison: false, loss_description: false })` returns empty arrays for all breakdowns.
  Run `npx wrangler dev` briefly and confirm the app still works (upload file → adjustments → calculate → results show charts).
  </verify>
  <done>
  - computeResults() accepts optional `dimensions` parameter
  - When dimensions omitted, all breakdowns computed (backward compatible)
  - When dimensions provided, only active breakdowns computed; inactive return []
  - CalculationResults return value includes `dimensions` field
  - Existing calculateResults() imperative orchestrator unchanged and working
  - TypeScript compiles cleanly
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npx wrangler dev` — app loads, existing wizard flow works end-to-end
3. src/lib/dimensions.ts has no imports from state/store or DOM APIs
4. computeResults() called without 3rd arg produces identical results to before
</verification>

<success_criteria>
- DimensionKey type and DimensionAvailability type exist and are importable
- detectDimensions() is a pure function that returns dimension availability for any CanonicalRecord[]
- computeResults() is dimension-aware but backward compatible
- CalculationResults carries dimensions metadata for downstream DIM-02 consumers
- Zero regressions in existing functionality
</success_criteria>

<output>
After completion, create `.planning/phases/03-calculation-engine-dimension-detection/03-01-SUMMARY.md`
</output>
